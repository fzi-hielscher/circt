//===- SimOps.cpp - Implement the Sim operations ------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file implements `sim` dialect ops.
//
//===----------------------------------------------------------------------===//

#include "circt/Dialect/Sim/SimOps.h"
#include "circt/Dialect/Arc/ArcOps.h"
#include "circt/Dialect/SV/SVOps.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"

#include "mlir/IR/PatternMatch.h"

using namespace mlir;
using namespace circt;
using namespace sim;

//===----------------------------------------------------------------------===//
// TableGen generated logic.
//===----------------------------------------------------------------------===//

// Provide the autogenerated implementation guts for the Op classes.
#define GET_OP_CLASSES
#include "circt/Dialect/Sim/Sim.cpp.inc"

OpFoldResult FormatLitOp::fold(FoldAdaptor adaptor) { return getLiteralAttr(); }

OpFoldResult FormatDecOp::fold(FoldAdaptor adaptor) {
  if (getValue().getType() == IntegerType::get(getContext(), 0U))
    return StringAttr::get(getContext(), "0");

  if (auto intAttr = llvm::dyn_cast_or_null<IntegerAttr>(adaptor.getValue())) {
    SmallVector<char, 16> strBuf;
    intAttr.getValue().toString(strBuf, 10U, getIsSigned());

    unsigned width = intAttr.getType().getIntOrFloatBitWidth();
    unsigned padWidth = FormatDecOp::getDecimalWidth(width, getIsSigned());
    padWidth = padWidth > strBuf.size() ? padWidth - strBuf.size() : 0;

    SmallVector<char, 32> padding(padWidth, ' ');
    return StringAttr::get(getContext(), Twine(padding) + Twine(strBuf));

    return StringAttr::get(getContext(), Twine(strBuf));
  }
  return {};
}

OpFoldResult FormatHexOp::fold(FoldAdaptor adaptor) {
  if (getValue().getType() == IntegerType::get(getContext(), 0U))
    return StringAttr::get(getContext(), "");

  if (auto intAttr = llvm::dyn_cast_or_null<IntegerAttr>(adaptor.getValue())) {
    SmallVector<char, 8> strBuf;
    intAttr.getValue().toString(strBuf, 16U, /*Signed*/ false,
                                /*formatAsCLiteral*/ false,
                                /*UpperCase*/ false);

    unsigned width = intAttr.getType().getIntOrFloatBitWidth();
    unsigned padWidth = width / 4;
    if (width % 4 != 0)
      padWidth++;
    padWidth = padWidth > strBuf.size() ? padWidth - strBuf.size() : 0;

    SmallVector<char, 8> padding(padWidth, '0');
    return StringAttr::get(getContext(), Twine(padding) + Twine(strBuf));
  }
  return {};
}

OpFoldResult FormatBinOp::fold(FoldAdaptor adaptor) {
  if (getValue().getType() == IntegerType::get(getContext(), 0U))
    return StringAttr::get(getContext(), "");

  if (auto intAttr = llvm::dyn_cast_or_null<IntegerAttr>(adaptor.getValue())) {
    SmallVector<char, 32> strBuf;
    intAttr.getValue().toString(strBuf, 2U, false);

    unsigned width = intAttr.getType().getIntOrFloatBitWidth();
    unsigned padWidth = width > strBuf.size() ? width - strBuf.size() : 0;

    SmallVector<char, 32> padding(padWidth, '0');
    return StringAttr::get(getContext(), Twine(padding) + Twine(strBuf));
  }
  return {};
}

OpFoldResult FormatCharOp::fold(FoldAdaptor adaptor) {
  if (auto intAttr = llvm::dyn_cast_or_null<IntegerAttr>(adaptor.getValue())) {
    if (intAttr.getType().getIntOrFloatBitWidth() > 8)
      return {};
    if (intAttr.getValue().isZero())
      return {};

    SmallString<1> str;
    str.push_back((char)intAttr.getValue().getZExtValue());

    return StringAttr::get(getContext(), str);
  }
  return {};
}

LogicalResult FormatLitOp::verify() {
  if (getLiteral().contains('\0'))
    return emitOpError(
        "Format literals must not contain null ('\\0') characters.");
  return success();
}

static StringAttr concatLiterals(MLIRContext *ctxt, ArrayRef<StringRef> lits) {
  assert(!lits.empty() && "No literals to concatenate");
  if (lits.size() == 1)
    return StringAttr::get(ctxt, lits.front());
  SmallString<64> newLit;
  for (auto lit : lits)
    newLit += lit;
  return StringAttr::get(ctxt, newLit);
}

OpFoldResult FormatStringConcatOp::fold(FoldAdaptor adaptor) {
  if (getNumOperands() == 1)
    return getOperand(0);

  SmallVector<StringRef> lits;
  for (auto attr : adaptor.getInputs()) {
    auto lit = dyn_cast_or_null<StringAttr>(attr);
    if (!lit)
      return {};
    lits.push_back(lit);
  }
  return concatLiterals(getContext(), lits);
}

LogicalResult FormatStringConcatOp::canonicalize(FormatStringConcatOp op,
                                                 PatternRewriter &rewriter) {
  if (op.getNumOperands() < 3)
    return failure(); // Should be handled by the folder

  // Check if there are adjacent literals we can merge
  bool canBeSimplified = false;
  bool predIsLit = false;
  for (auto oper : op.getOperands())
    if (isa_and_nonnull<FormatLitOp>(oper.getDefiningOp())) {
      if (predIsLit) {
        canBeSimplified = true;
        break;
      }
      predIsLit = true;
    } else {
      predIsLit = false;
    }

  if (!canBeSimplified)
    return failure();

  SmallVector<StringRef> litSequence;
  SmallVector<Value> newOperands;
  for (auto operand : op.getOperands()) {
    if (auto litOp = operand.getDefiningOp<FormatLitOp>()) {
      litSequence.push_back(litOp.getLiteral());
    } else {
      if (!litSequence.empty()) {
        auto newLit = rewriter.createOrFold<FormatLitOp>(
            op.getLoc(), FormatStringType::get(op.getContext()),
            concatLiterals(op.getContext(), litSequence));
        newOperands.push_back(newLit);
        litSequence.clear();
      }
      newOperands.push_back(operand);
    }
  }

  if (!litSequence.empty()) {
    auto newLit = rewriter.createOrFold<FormatLitOp>(
        op.getLoc(), FormatStringType::get(op.getContext()),
        concatLiterals(op.getContext(), litSequence));
    newOperands.push_back(newLit);
  }

  rewriter.modifyOpInPlace(op, [&]() { op->setOperands(newOperands); });

  return success();
}

LogicalResult PrintFormattedOp::canonicalize(PrintFormattedOp op,
                                             PatternRewriter &rewriter) {
  if (auto cstCond = op.getCondition().getDefiningOp<hw::ConstantOp>()) {
    if (cstCond.getValue().isZero()) {
      op.erase();
      return success();
    }
  }
  return failure();
}

LogicalResult PrintFormattedProcOp::verify() {
  if (!getOperation()->getParentOfType<hw::TriggeredOp>() &&
      !getOperation()->getParentWithTrait<sv::ProceduralRegion>() &&
      !getOperation()->getParentOfType<arc::ClockTreeOp>() &&
      !getOperation()->getParentOfType<func::FuncOp>()) {
    return emitOpError("PrintFormattedProcOp must be in a procedural region");
  }
  return success();
}
